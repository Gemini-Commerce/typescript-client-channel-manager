/* tslint:disable */
/* eslint-disable */
/**
 * Channel Manager Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@gemini-commerce.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ChannelmanagerAssociationResponse
 */
export interface ChannelmanagerAssociationResponse {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerAssociationResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerAssociationResponse
     */
    'grn'?: string;
    /**
     * 
     * @type {ChannelmanagerAssociationResponseAssociation}
     * @memberof ChannelmanagerAssociationResponse
     */
    'associationEntities'?: ChannelmanagerAssociationResponseAssociation;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerAssociationResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerAssociationResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerAssociationResponseAssociation
 */
export interface ChannelmanagerAssociationResponseAssociation {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerAssociationResponseAssociation
     */
    'channelGrn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerAssociationResponseAssociation
     */
    'marketGrn'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerChannelResponse
 */
export interface ChannelmanagerChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponse
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponse
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponse
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponse
     */
    'name'?: string;
    /**
     * 
     * @type {ChannelmanagerLanguageCode}
     * @memberof ChannelmanagerChannelResponse
     */
    'defaultLanguage'?: ChannelmanagerLanguageCode;
    /**
     * 
     * @type {ChannelmanagerChannelSettings}
     * @memberof ChannelmanagerChannelResponse
     */
    'settings'?: ChannelmanagerChannelSettings;
    /**
     * 
     * @type {ChannelmanagerChannelTypeWebsite}
     * @memberof ChannelmanagerChannelResponse
     */
    'website'?: ChannelmanagerChannelTypeWebsite;
    /**
     * 
     * @type {ChannelmanagerChannelStatus}
     * @memberof ChannelmanagerChannelResponse
     */
    'status'?: ChannelmanagerChannelStatus;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponse
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface ChannelmanagerChannelResponseWithAssociations
 */
export interface ChannelmanagerChannelResponseWithAssociations {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'name'?: string;
    /**
     * 
     * @type {ChannelmanagerLanguageCode}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'defaultLanguage'?: ChannelmanagerLanguageCode;
    /**
     * 
     * @type {ChannelmanagerChannelSettings}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'settings'?: ChannelmanagerChannelSettings;
    /**
     * 
     * @type {ChannelmanagerChannelTypeWebsite}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'website'?: ChannelmanagerChannelTypeWebsite;
    /**
     * 
     * @type {Array<ChannelmanagerChannelResponseWithAssociationsAssociation>}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'associations'?: Array<ChannelmanagerChannelResponseWithAssociationsAssociation>;
    /**
     * 
     * @type {ChannelmanagerChannelStatus}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'status'?: ChannelmanagerChannelStatus;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelResponseWithAssociations
     */
    'updatedAt'?: string;
}


/**
 * 
 * @export
 * @interface ChannelmanagerChannelResponseWithAssociationsAssociation
 */
export interface ChannelmanagerChannelResponseWithAssociationsAssociation {
    /**
     * 
     * @type {ChannelmanagerMarketResponse}
     * @memberof ChannelmanagerChannelResponseWithAssociationsAssociation
     */
    'market'?: ChannelmanagerMarketResponse;
}
/**
 * 
 * @export
 * @interface ChannelmanagerChannelSettings
 */
export interface ChannelmanagerChannelSettings {
    /**
     * 
     * @type {boolean}
     * @memberof ChannelmanagerChannelSettings
     */
    'hideOosProducts'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelmanagerChannelSettings
     */
    'hidePricelessProducts'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChannelmanagerChannelStatus = {
    Unknown: 'CH_STATUS_UNKNOWN',
    Active: 'CH_STATUS_ACTIVE',
    Disabled: 'CH_STATUS_DISABLED',
    UnderMaintenance: 'CH_STATUS_UNDER_MAINTENANCE'
} as const;

export type ChannelmanagerChannelStatus = typeof ChannelmanagerChannelStatus[keyof typeof ChannelmanagerChannelStatus];


/**
 * 
 * @export
 * @interface ChannelmanagerChannelTypeWebsite
 */
export interface ChannelmanagerChannelTypeWebsite {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerChannelTypeWebsite
     */
    'domain'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChannelmanagerCountryCode = {
    Unknown: 'COUNTRY_CODE_UNKNOWN',
    Ad: 'COUNTRY_CODE_AD',
    Ae: 'COUNTRY_CODE_AE',
    Af: 'COUNTRY_CODE_AF',
    Ag: 'COUNTRY_CODE_AG',
    Ai: 'COUNTRY_CODE_AI',
    Al: 'COUNTRY_CODE_AL',
    Am: 'COUNTRY_CODE_AM',
    Ao: 'COUNTRY_CODE_AO',
    Aq: 'COUNTRY_CODE_AQ',
    Ar: 'COUNTRY_CODE_AR',
    As: 'COUNTRY_CODE_AS',
    At: 'COUNTRY_CODE_AT',
    Au: 'COUNTRY_CODE_AU',
    Aw: 'COUNTRY_CODE_AW',
    Ax: 'COUNTRY_CODE_AX',
    Az: 'COUNTRY_CODE_AZ',
    Ba: 'COUNTRY_CODE_BA',
    Bb: 'COUNTRY_CODE_BB',
    Bd: 'COUNTRY_CODE_BD',
    Be: 'COUNTRY_CODE_BE',
    Bf: 'COUNTRY_CODE_BF',
    Bg: 'COUNTRY_CODE_BG',
    Bh: 'COUNTRY_CODE_BH',
    Bi: 'COUNTRY_CODE_BI',
    Bj: 'COUNTRY_CODE_BJ',
    Bl: 'COUNTRY_CODE_BL',
    Bm: 'COUNTRY_CODE_BM',
    Bn: 'COUNTRY_CODE_BN',
    Bo: 'COUNTRY_CODE_BO',
    Bq: 'COUNTRY_CODE_BQ',
    Br: 'COUNTRY_CODE_BR',
    Bs: 'COUNTRY_CODE_BS',
    Bt: 'COUNTRY_CODE_BT',
    Bv: 'COUNTRY_CODE_BV',
    Bw: 'COUNTRY_CODE_BW',
    By: 'COUNTRY_CODE_BY',
    Bz: 'COUNTRY_CODE_BZ',
    Ca: 'COUNTRY_CODE_CA',
    Cc: 'COUNTRY_CODE_CC',
    Cd: 'COUNTRY_CODE_CD',
    Cf: 'COUNTRY_CODE_CF',
    Cg: 'COUNTRY_CODE_CG',
    Ch: 'COUNTRY_CODE_CH',
    Ci: 'COUNTRY_CODE_CI',
    Ck: 'COUNTRY_CODE_CK',
    Cl: 'COUNTRY_CODE_CL',
    Cm: 'COUNTRY_CODE_CM',
    Cn: 'COUNTRY_CODE_CN',
    Co: 'COUNTRY_CODE_CO',
    Cr: 'COUNTRY_CODE_CR',
    Cu: 'COUNTRY_CODE_CU',
    Cv: 'COUNTRY_CODE_CV',
    Cw: 'COUNTRY_CODE_CW',
    Cx: 'COUNTRY_CODE_CX',
    Cy: 'COUNTRY_CODE_CY',
    Cz: 'COUNTRY_CODE_CZ',
    De: 'COUNTRY_CODE_DE',
    Dj: 'COUNTRY_CODE_DJ',
    Dk: 'COUNTRY_CODE_DK',
    Dm: 'COUNTRY_CODE_DM',
    Do: 'COUNTRY_CODE_DO',
    Dz: 'COUNTRY_CODE_DZ',
    Ec: 'COUNTRY_CODE_EC',
    Ee: 'COUNTRY_CODE_EE',
    Eg: 'COUNTRY_CODE_EG',
    Eh: 'COUNTRY_CODE_EH',
    Er: 'COUNTRY_CODE_ER',
    Es: 'COUNTRY_CODE_ES',
    Et: 'COUNTRY_CODE_ET',
    Fi: 'COUNTRY_CODE_FI',
    Fj: 'COUNTRY_CODE_FJ',
    Fk: 'COUNTRY_CODE_FK',
    Fm: 'COUNTRY_CODE_FM',
    Fo: 'COUNTRY_CODE_FO',
    Fr: 'COUNTRY_CODE_FR',
    Ga: 'COUNTRY_CODE_GA',
    Gb: 'COUNTRY_CODE_GB',
    Gd: 'COUNTRY_CODE_GD',
    Ge: 'COUNTRY_CODE_GE',
    Gf: 'COUNTRY_CODE_GF',
    Gg: 'COUNTRY_CODE_GG',
    Gh: 'COUNTRY_CODE_GH',
    Gi: 'COUNTRY_CODE_GI',
    Gl: 'COUNTRY_CODE_GL',
    Gm: 'COUNTRY_CODE_GM',
    Gn: 'COUNTRY_CODE_GN',
    Gp: 'COUNTRY_CODE_GP',
    Gq: 'COUNTRY_CODE_GQ',
    Gr: 'COUNTRY_CODE_GR',
    Gs: 'COUNTRY_CODE_GS',
    Gt: 'COUNTRY_CODE_GT',
    Gu: 'COUNTRY_CODE_GU',
    Gw: 'COUNTRY_CODE_GW',
    Gy: 'COUNTRY_CODE_GY',
    Hk: 'COUNTRY_CODE_HK',
    Hm: 'COUNTRY_CODE_HM',
    Hn: 'COUNTRY_CODE_HN',
    Hr: 'COUNTRY_CODE_HR',
    Ht: 'COUNTRY_CODE_HT',
    Hu: 'COUNTRY_CODE_HU',
    Id: 'COUNTRY_CODE_ID',
    Ie: 'COUNTRY_CODE_IE',
    Il: 'COUNTRY_CODE_IL',
    Im: 'COUNTRY_CODE_IM',
    In: 'COUNTRY_CODE_IN',
    Io: 'COUNTRY_CODE_IO',
    Iq: 'COUNTRY_CODE_IQ',
    Ir: 'COUNTRY_CODE_IR',
    Is: 'COUNTRY_CODE_IS',
    It: 'COUNTRY_CODE_IT',
    Je: 'COUNTRY_CODE_JE',
    Jm: 'COUNTRY_CODE_JM',
    Jo: 'COUNTRY_CODE_JO',
    Jp: 'COUNTRY_CODE_JP',
    Ke: 'COUNTRY_CODE_KE',
    Kg: 'COUNTRY_CODE_KG',
    Kh: 'COUNTRY_CODE_KH',
    Ki: 'COUNTRY_CODE_KI',
    Km: 'COUNTRY_CODE_KM',
    Kn: 'COUNTRY_CODE_KN',
    Kp: 'COUNTRY_CODE_KP',
    Kr: 'COUNTRY_CODE_KR',
    Kw: 'COUNTRY_CODE_KW',
    Ky: 'COUNTRY_CODE_KY',
    Kz: 'COUNTRY_CODE_KZ',
    La: 'COUNTRY_CODE_LA',
    Lb: 'COUNTRY_CODE_LB',
    Lc: 'COUNTRY_CODE_LC',
    Li: 'COUNTRY_CODE_LI',
    Lk: 'COUNTRY_CODE_LK',
    Lr: 'COUNTRY_CODE_LR',
    Ls: 'COUNTRY_CODE_LS',
    Lt: 'COUNTRY_CODE_LT',
    Lu: 'COUNTRY_CODE_LU',
    Lv: 'COUNTRY_CODE_LV',
    Ly: 'COUNTRY_CODE_LY',
    Ma: 'COUNTRY_CODE_MA',
    Mc: 'COUNTRY_CODE_MC',
    Md: 'COUNTRY_CODE_MD',
    Me: 'COUNTRY_CODE_ME',
    Mf: 'COUNTRY_CODE_MF',
    Mg: 'COUNTRY_CODE_MG',
    Mh: 'COUNTRY_CODE_MH',
    Mk: 'COUNTRY_CODE_MK',
    Ml: 'COUNTRY_CODE_ML',
    Mm: 'COUNTRY_CODE_MM',
    Mn: 'COUNTRY_CODE_MN',
    Mo: 'COUNTRY_CODE_MO',
    Mp: 'COUNTRY_CODE_MP',
    Mq: 'COUNTRY_CODE_MQ',
    Mr: 'COUNTRY_CODE_MR',
    Ms: 'COUNTRY_CODE_MS',
    Mt: 'COUNTRY_CODE_MT',
    Mu: 'COUNTRY_CODE_MU',
    Mv: 'COUNTRY_CODE_MV',
    Mw: 'COUNTRY_CODE_MW',
    Mx: 'COUNTRY_CODE_MX',
    My: 'COUNTRY_CODE_MY',
    Mz: 'COUNTRY_CODE_MZ',
    Na: 'COUNTRY_CODE_NA',
    Nc: 'COUNTRY_CODE_NC',
    Ne: 'COUNTRY_CODE_NE',
    Nf: 'COUNTRY_CODE_NF',
    Ng: 'COUNTRY_CODE_NG',
    Ni: 'COUNTRY_CODE_NI',
    Nl: 'COUNTRY_CODE_NL',
    No: 'COUNTRY_CODE_NO',
    Np: 'COUNTRY_CODE_NP',
    Nr: 'COUNTRY_CODE_NR',
    Nu: 'COUNTRY_CODE_NU',
    Nz: 'COUNTRY_CODE_NZ',
    Om: 'COUNTRY_CODE_OM',
    Pa: 'COUNTRY_CODE_PA',
    Pe: 'COUNTRY_CODE_PE',
    Pf: 'COUNTRY_CODE_PF',
    Pg: 'COUNTRY_CODE_PG',
    Ph: 'COUNTRY_CODE_PH',
    Pk: 'COUNTRY_CODE_PK',
    Pl: 'COUNTRY_CODE_PL',
    Pm: 'COUNTRY_CODE_PM',
    Pn: 'COUNTRY_CODE_PN',
    Pr: 'COUNTRY_CODE_PR',
    Ps: 'COUNTRY_CODE_PS',
    Pt: 'COUNTRY_CODE_PT',
    Pw: 'COUNTRY_CODE_PW',
    Py: 'COUNTRY_CODE_PY',
    Qa: 'COUNTRY_CODE_QA',
    Re: 'COUNTRY_CODE_RE',
    Ro: 'COUNTRY_CODE_RO',
    Rs: 'COUNTRY_CODE_RS',
    Ru: 'COUNTRY_CODE_RU',
    Rw: 'COUNTRY_CODE_RW',
    Sa: 'COUNTRY_CODE_SA',
    Sb: 'COUNTRY_CODE_SB',
    Sc: 'COUNTRY_CODE_SC',
    Sd: 'COUNTRY_CODE_SD',
    Se: 'COUNTRY_CODE_SE',
    Sg: 'COUNTRY_CODE_SG',
    Sh: 'COUNTRY_CODE_SH',
    Si: 'COUNTRY_CODE_SI',
    Sj: 'COUNTRY_CODE_SJ',
    Sk: 'COUNTRY_CODE_SK',
    Sl: 'COUNTRY_CODE_SL',
    Sm: 'COUNTRY_CODE_SM',
    Sn: 'COUNTRY_CODE_SN',
    So: 'COUNTRY_CODE_SO',
    Sr: 'COUNTRY_CODE_SR',
    Ss: 'COUNTRY_CODE_SS',
    St: 'COUNTRY_CODE_ST',
    Sv: 'COUNTRY_CODE_SV',
    Sx: 'COUNTRY_CODE_SX',
    Sy: 'COUNTRY_CODE_SY',
    Sz: 'COUNTRY_CODE_SZ',
    Tc: 'COUNTRY_CODE_TC',
    Td: 'COUNTRY_CODE_TD',
    Tf: 'COUNTRY_CODE_TF',
    Tg: 'COUNTRY_CODE_TG',
    Th: 'COUNTRY_CODE_TH',
    Tj: 'COUNTRY_CODE_TJ',
    Tk: 'COUNTRY_CODE_TK',
    Tl: 'COUNTRY_CODE_TL',
    Tm: 'COUNTRY_CODE_TM',
    Tn: 'COUNTRY_CODE_TN',
    To: 'COUNTRY_CODE_TO',
    Tr: 'COUNTRY_CODE_TR',
    Tt: 'COUNTRY_CODE_TT',
    Tv: 'COUNTRY_CODE_TV',
    Tw: 'COUNTRY_CODE_TW',
    Tz: 'COUNTRY_CODE_TZ',
    Ua: 'COUNTRY_CODE_UA',
    Ug: 'COUNTRY_CODE_UG',
    Um: 'COUNTRY_CODE_UM',
    Us: 'COUNTRY_CODE_US',
    Uy: 'COUNTRY_CODE_UY',
    Uz: 'COUNTRY_CODE_UZ',
    Va: 'COUNTRY_CODE_VA',
    Vc: 'COUNTRY_CODE_VC',
    Ve: 'COUNTRY_CODE_VE',
    Vg: 'COUNTRY_CODE_VG',
    Vi: 'COUNTRY_CODE_VI',
    Vn: 'COUNTRY_CODE_VN',
    Vu: 'COUNTRY_CODE_VU',
    Wf: 'COUNTRY_CODE_WF',
    Ws: 'COUNTRY_CODE_WS',
    Ye: 'COUNTRY_CODE_YE',
    Yt: 'COUNTRY_CODE_YT',
    Za: 'COUNTRY_CODE_ZA',
    Zm: 'COUNTRY_CODE_ZM',
    Zw: 'COUNTRY_CODE_ZW',
    Xk: 'COUNTRY_CODE_XK'
} as const;

export type ChannelmanagerCountryCode = typeof ChannelmanagerCountryCode[keyof typeof ChannelmanagerCountryCode];


/**
 * 
 * @export
 * @interface ChannelmanagerCreateAssociationRequest
 */
export interface ChannelmanagerCreateAssociationRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerCreateAssociationRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerCreateAssociationRequest
     */
    'channelGrn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerCreateAssociationRequest
     */
    'marketGrn'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerCreateChannelRequest
 */
export interface ChannelmanagerCreateChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerCreateChannelRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerCreateChannelRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerCreateChannelRequest
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerCreateChannelRequest
     */
    'name'?: string;
    /**
     * 
     * @type {ChannelmanagerLanguageCode}
     * @memberof ChannelmanagerCreateChannelRequest
     */
    'defaultLanguage'?: ChannelmanagerLanguageCode;
    /**
     * 
     * @type {ChannelmanagerChannelSettings}
     * @memberof ChannelmanagerCreateChannelRequest
     */
    'settings'?: ChannelmanagerChannelSettings;
    /**
     * 
     * @type {ChannelmanagerChannelTypeWebsite}
     * @memberof ChannelmanagerCreateChannelRequest
     */
    'website'?: ChannelmanagerChannelTypeWebsite;
    /**
     * 
     * @type {ChannelmanagerChannelStatus}
     * @memberof ChannelmanagerCreateChannelRequest
     */
    'status'?: ChannelmanagerChannelStatus;
}


/**
 * 
 * @export
 * @interface ChannelmanagerCreateMarketRequest
 */
export interface ChannelmanagerCreateMarketRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerCreateMarketRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerCreateMarketRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerCreateMarketRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ChannelmanagerCountryCode>}
     * @memberof ChannelmanagerCreateMarketRequest
     */
    'countries'?: Array<ChannelmanagerCountryCode>;
}
/**
 * 
 * @export
 * @interface ChannelmanagerDeleteAssociationRequest
 */
export interface ChannelmanagerDeleteAssociationRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerDeleteAssociationRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerDeleteAssociationRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerDeleteChannelRequest
 */
export interface ChannelmanagerDeleteChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerDeleteChannelRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerDeleteChannelRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerDeleteMarketRequest
 */
export interface ChannelmanagerDeleteMarketRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerDeleteMarketRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerDeleteMarketRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerGetChannelRequest
 */
export interface ChannelmanagerGetChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerGetChannelRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerGetChannelRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerGetChannelWithAssociationsRequest
 */
export interface ChannelmanagerGetChannelWithAssociationsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerGetChannelWithAssociationsRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerGetChannelWithAssociationsRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerGetMarketRequest
 */
export interface ChannelmanagerGetMarketRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerGetMarketRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerGetMarketRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerGetMarketWithAssociationsRequest
 */
export interface ChannelmanagerGetMarketWithAssociationsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerGetMarketWithAssociationsRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerGetMarketWithAssociationsRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChannelmanagerLanguageCode = {
    Unknown: 'LANGUAGE_CODE_UNKNOWN',
    Aa: 'LANGUAGE_CODE_AA',
    Ab: 'LANGUAGE_CODE_AB',
    Ae: 'LANGUAGE_CODE_AE',
    Af: 'LANGUAGE_CODE_AF',
    Ak: 'LANGUAGE_CODE_AK',
    Am: 'LANGUAGE_CODE_AM',
    An: 'LANGUAGE_CODE_AN',
    Ar: 'LANGUAGE_CODE_AR',
    As: 'LANGUAGE_CODE_AS',
    Av: 'LANGUAGE_CODE_AV',
    Ay: 'LANGUAGE_CODE_AY',
    Az: 'LANGUAGE_CODE_AZ',
    Ba: 'LANGUAGE_CODE_BA',
    Be: 'LANGUAGE_CODE_BE',
    Bg: 'LANGUAGE_CODE_BG',
    Bh: 'LANGUAGE_CODE_BH',
    Bm: 'LANGUAGE_CODE_BM',
    Bi: 'LANGUAGE_CODE_BI',
    Bn: 'LANGUAGE_CODE_BN',
    Bo: 'LANGUAGE_CODE_BO',
    Br: 'LANGUAGE_CODE_BR',
    Bs: 'LANGUAGE_CODE_BS',
    Ca: 'LANGUAGE_CODE_CA',
    Ce: 'LANGUAGE_CODE_CE',
    Ch: 'LANGUAGE_CODE_CH',
    Co: 'LANGUAGE_CODE_CO',
    Cr: 'LANGUAGE_CODE_CR',
    Cs: 'LANGUAGE_CODE_CS',
    Cu: 'LANGUAGE_CODE_CU',
    Cv: 'LANGUAGE_CODE_CV',
    Cy: 'LANGUAGE_CODE_CY',
    Da: 'LANGUAGE_CODE_DA',
    De: 'LANGUAGE_CODE_DE',
    Dv: 'LANGUAGE_CODE_DV',
    Dz: 'LANGUAGE_CODE_DZ',
    Ee: 'LANGUAGE_CODE_EE',
    El: 'LANGUAGE_CODE_EL',
    En: 'LANGUAGE_CODE_EN',
    Eo: 'LANGUAGE_CODE_EO',
    Es: 'LANGUAGE_CODE_ES',
    Et: 'LANGUAGE_CODE_ET',
    Eu: 'LANGUAGE_CODE_EU',
    Fa: 'LANGUAGE_CODE_FA',
    Ff: 'LANGUAGE_CODE_FF',
    Fi: 'LANGUAGE_CODE_FI',
    Fj: 'LANGUAGE_CODE_FJ',
    Fo: 'LANGUAGE_CODE_FO',
    Fr: 'LANGUAGE_CODE_FR',
    Fy: 'LANGUAGE_CODE_FY',
    Ga: 'LANGUAGE_CODE_GA',
    Gd: 'LANGUAGE_CODE_GD',
    Gl: 'LANGUAGE_CODE_GL',
    Gn: 'LANGUAGE_CODE_GN',
    Gu: 'LANGUAGE_CODE_GU',
    Gv: 'LANGUAGE_CODE_GV',
    Ha: 'LANGUAGE_CODE_HA',
    He: 'LANGUAGE_CODE_HE',
    Hi: 'LANGUAGE_CODE_HI',
    Ho: 'LANGUAGE_CODE_HO',
    Hr: 'LANGUAGE_CODE_HR',
    Ht: 'LANGUAGE_CODE_HT',
    Hu: 'LANGUAGE_CODE_HU',
    Hy: 'LANGUAGE_CODE_HY',
    Hz: 'LANGUAGE_CODE_HZ',
    Ia: 'LANGUAGE_CODE_IA',
    Id: 'LANGUAGE_CODE_ID',
    Ie: 'LANGUAGE_CODE_IE',
    Ig: 'LANGUAGE_CODE_IG',
    Ii: 'LANGUAGE_CODE_II',
    Ik: 'LANGUAGE_CODE_IK',
    Io: 'LANGUAGE_CODE_IO',
    Is: 'LANGUAGE_CODE_IS',
    It: 'LANGUAGE_CODE_IT',
    Iu: 'LANGUAGE_CODE_IU',
    Ja: 'LANGUAGE_CODE_JA',
    Jv: 'LANGUAGE_CODE_JV',
    Ka: 'LANGUAGE_CODE_KA',
    Kg: 'LANGUAGE_CODE_KG',
    Ki: 'LANGUAGE_CODE_KI',
    Kj: 'LANGUAGE_CODE_KJ',
    Kk: 'LANGUAGE_CODE_KK',
    Kl: 'LANGUAGE_CODE_KL',
    Km: 'LANGUAGE_CODE_KM',
    Kn: 'LANGUAGE_CODE_KN',
    Ko: 'LANGUAGE_CODE_KO',
    Kr: 'LANGUAGE_CODE_KR',
    Ks: 'LANGUAGE_CODE_KS',
    Ku: 'LANGUAGE_CODE_KU',
    Kv: 'LANGUAGE_CODE_KV',
    Kw: 'LANGUAGE_CODE_KW',
    Ky: 'LANGUAGE_CODE_KY',
    La: 'LANGUAGE_CODE_LA',
    Lb: 'LANGUAGE_CODE_LB',
    Lg: 'LANGUAGE_CODE_LG',
    Li: 'LANGUAGE_CODE_LI',
    Ln: 'LANGUAGE_CODE_LN',
    Lo: 'LANGUAGE_CODE_LO',
    Lt: 'LANGUAGE_CODE_LT',
    Lu: 'LANGUAGE_CODE_LU',
    Lv: 'LANGUAGE_CODE_LV',
    Mg: 'LANGUAGE_CODE_MG',
    Mh: 'LANGUAGE_CODE_MH',
    Mi: 'LANGUAGE_CODE_MI',
    Mk: 'LANGUAGE_CODE_MK',
    Ml: 'LANGUAGE_CODE_ML',
    Mn: 'LANGUAGE_CODE_MN',
    Mr: 'LANGUAGE_CODE_MR',
    Ms: 'LANGUAGE_CODE_MS',
    Mt: 'LANGUAGE_CODE_MT',
    My: 'LANGUAGE_CODE_MY',
    Na: 'LANGUAGE_CODE_NA',
    Nb: 'LANGUAGE_CODE_NB',
    Nd: 'LANGUAGE_CODE_ND',
    Ne: 'LANGUAGE_CODE_NE',
    Ng: 'LANGUAGE_CODE_NG',
    Nl: 'LANGUAGE_CODE_NL',
    Nn: 'LANGUAGE_CODE_NN',
    No: 'LANGUAGE_CODE_NO',
    Nr: 'LANGUAGE_CODE_NR',
    Nv: 'LANGUAGE_CODE_NV',
    Ny: 'LANGUAGE_CODE_NY',
    Oc: 'LANGUAGE_CODE_OC',
    Oj: 'LANGUAGE_CODE_OJ',
    Om: 'LANGUAGE_CODE_OM',
    Or: 'LANGUAGE_CODE_OR',
    Os: 'LANGUAGE_CODE_OS',
    Pa: 'LANGUAGE_CODE_PA',
    Pi: 'LANGUAGE_CODE_PI',
    Pl: 'LANGUAGE_CODE_PL',
    Ps: 'LANGUAGE_CODE_PS',
    Pt: 'LANGUAGE_CODE_PT',
    Qu: 'LANGUAGE_CODE_QU',
    Rm: 'LANGUAGE_CODE_RM',
    Rn: 'LANGUAGE_CODE_RN',
    Ro: 'LANGUAGE_CODE_RO',
    Ru: 'LANGUAGE_CODE_RU',
    Rw: 'LANGUAGE_CODE_RW',
    Sa: 'LANGUAGE_CODE_SA',
    Sc: 'LANGUAGE_CODE_SC',
    Sd: 'LANGUAGE_CODE_SD',
    Se: 'LANGUAGE_CODE_SE',
    Sg: 'LANGUAGE_CODE_SG',
    Si: 'LANGUAGE_CODE_SI',
    Sk: 'LANGUAGE_CODE_SK',
    Sl: 'LANGUAGE_CODE_SL',
    Sm: 'LANGUAGE_CODE_SM',
    Sn: 'LANGUAGE_CODE_SN',
    So: 'LANGUAGE_CODE_SO',
    Sq: 'LANGUAGE_CODE_SQ',
    Sr: 'LANGUAGE_CODE_SR',
    Ss: 'LANGUAGE_CODE_SS',
    St: 'LANGUAGE_CODE_ST',
    Su: 'LANGUAGE_CODE_SU',
    Sv: 'LANGUAGE_CODE_SV',
    Sw: 'LANGUAGE_CODE_SW',
    Ta: 'LANGUAGE_CODE_TA',
    Te: 'LANGUAGE_CODE_TE',
    Tg: 'LANGUAGE_CODE_TG',
    Th: 'LANGUAGE_CODE_TH',
    Ti: 'LANGUAGE_CODE_TI',
    Tk: 'LANGUAGE_CODE_TK',
    Tl: 'LANGUAGE_CODE_TL',
    Tn: 'LANGUAGE_CODE_TN',
    To: 'LANGUAGE_CODE_TO',
    Tr: 'LANGUAGE_CODE_TR',
    Ts: 'LANGUAGE_CODE_TS',
    Tt: 'LANGUAGE_CODE_TT',
    Tw: 'LANGUAGE_CODE_TW',
    Ty: 'LANGUAGE_CODE_TY',
    Ug: 'LANGUAGE_CODE_UG',
    Uk: 'LANGUAGE_CODE_UK',
    Ur: 'LANGUAGE_CODE_UR',
    Uz: 'LANGUAGE_CODE_UZ',
    Ve: 'LANGUAGE_CODE_VE',
    Vi: 'LANGUAGE_CODE_VI',
    Vo: 'LANGUAGE_CODE_VO',
    Wa: 'LANGUAGE_CODE_WA',
    Wo: 'LANGUAGE_CODE_WO',
    Xh: 'LANGUAGE_CODE_XH',
    Yi: 'LANGUAGE_CODE_YI',
    Yo: 'LANGUAGE_CODE_YO',
    Za: 'LANGUAGE_CODE_ZA',
    Zh: 'LANGUAGE_CODE_ZH',
    Zu: 'LANGUAGE_CODE_ZU'
} as const;

export type ChannelmanagerLanguageCode = typeof ChannelmanagerLanguageCode[keyof typeof ChannelmanagerLanguageCode];


/**
 * 
 * @export
 * @interface ChannelmanagerListChannelsRequest
 */
export interface ChannelmanagerListChannelsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListChannelsRequest
     */
    'tenantId'?: string;
    /**
     * The number of items to return per page. If not specified, it will returns all items.
     * @type {number}
     * @memberof ChannelmanagerListChannelsRequest
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListChannelsRequest
     */
    'pageToken'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerListChannelsResponse
 */
export interface ChannelmanagerListChannelsResponse {
    /**
     * 
     * @type {Array<ChannelmanagerChannelResponse>}
     * @memberof ChannelmanagerListChannelsResponse
     */
    'channels'?: Array<ChannelmanagerChannelResponse>;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListChannelsResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerListChannelsWithAssociationsRequest
 */
export interface ChannelmanagerListChannelsWithAssociationsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListChannelsWithAssociationsRequest
     */
    'tenantId'?: string;
    /**
     * The number of items to return per page. If not specified, it will returns all items.
     * @type {number}
     * @memberof ChannelmanagerListChannelsWithAssociationsRequest
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListChannelsWithAssociationsRequest
     */
    'pageToken'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerListChannelsWithAssociationsResponse
 */
export interface ChannelmanagerListChannelsWithAssociationsResponse {
    /**
     * 
     * @type {Array<ChannelmanagerChannelResponseWithAssociations>}
     * @memberof ChannelmanagerListChannelsWithAssociationsResponse
     */
    'channels'?: Array<ChannelmanagerChannelResponseWithAssociations>;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListChannelsWithAssociationsResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerListMarketsRequest
 */
export interface ChannelmanagerListMarketsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListMarketsRequest
     */
    'tenantId'?: string;
    /**
     * The number of items to return per page. If not specified, it will returns all items.
     * @type {number}
     * @memberof ChannelmanagerListMarketsRequest
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListMarketsRequest
     */
    'pageToken'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerListMarketsResponse
 */
export interface ChannelmanagerListMarketsResponse {
    /**
     * 
     * @type {Array<ChannelmanagerMarketResponse>}
     * @memberof ChannelmanagerListMarketsResponse
     */
    'markets'?: Array<ChannelmanagerMarketResponse>;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListMarketsResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerListMarketsWithAssociationsRequest
 */
export interface ChannelmanagerListMarketsWithAssociationsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListMarketsWithAssociationsRequest
     */
    'tenantId'?: string;
    /**
     * The number of items to return per page. If not specified, it will returns all items.
     * @type {number}
     * @memberof ChannelmanagerListMarketsWithAssociationsRequest
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListMarketsWithAssociationsRequest
     */
    'pageToken'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerListMarketsWithAssociationsResponse
 */
export interface ChannelmanagerListMarketsWithAssociationsResponse {
    /**
     * 
     * @type {Array<ChannelmanagerMarketResponseWithAssociations>}
     * @memberof ChannelmanagerListMarketsWithAssociationsResponse
     */
    'markets'?: Array<ChannelmanagerMarketResponseWithAssociations>;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerListMarketsWithAssociationsResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerMarketResponse
 */
export interface ChannelmanagerMarketResponse {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponse
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponse
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ChannelmanagerCountryCode>}
     * @memberof ChannelmanagerMarketResponse
     */
    'countries'?: Array<ChannelmanagerCountryCode>;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerMarketResponseWithAssociations
 */
export interface ChannelmanagerMarketResponseWithAssociations {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponseWithAssociations
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponseWithAssociations
     */
    'grn'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponseWithAssociations
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponseWithAssociations
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ChannelmanagerCountryCode>}
     * @memberof ChannelmanagerMarketResponseWithAssociations
     */
    'countries'?: Array<ChannelmanagerCountryCode>;
    /**
     * 
     * @type {Array<ChannelmanagerMarketResponseWithAssociationsAssociation>}
     * @memberof ChannelmanagerMarketResponseWithAssociations
     */
    'associations'?: Array<ChannelmanagerMarketResponseWithAssociationsAssociation>;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponseWithAssociations
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerMarketResponseWithAssociations
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ChannelmanagerMarketResponseWithAssociationsAssociation
 */
export interface ChannelmanagerMarketResponseWithAssociationsAssociation {
    /**
     * 
     * @type {ChannelmanagerChannelResponse}
     * @memberof ChannelmanagerMarketResponseWithAssociationsAssociation
     */
    'channel'?: ChannelmanagerChannelResponse;
}
/**
 * 
 * @export
 * @interface ChannelmanagerUpdateChannelRequest
 */
export interface ChannelmanagerUpdateChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerUpdateChannelRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerUpdateChannelRequest
     */
    'id'?: string;
    /**
     * 
     * @type {ChannelmanagerUpdateChannelRequestPayload}
     * @memberof ChannelmanagerUpdateChannelRequest
     */
    'payload'?: ChannelmanagerUpdateChannelRequestPayload;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChannelmanagerUpdateChannelRequest
     */
    'payloadMask'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ChannelmanagerUpdateChannelRequestPayload
 */
export interface ChannelmanagerUpdateChannelRequestPayload {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerUpdateChannelRequestPayload
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerUpdateChannelRequestPayload
     */
    'name'?: string;
    /**
     * 
     * @type {ChannelmanagerLanguageCode}
     * @memberof ChannelmanagerUpdateChannelRequestPayload
     */
    'defaultLanguage'?: ChannelmanagerLanguageCode;
    /**
     * 
     * @type {ChannelmanagerChannelSettings}
     * @memberof ChannelmanagerUpdateChannelRequestPayload
     */
    'settings'?: ChannelmanagerChannelSettings;
    /**
     * 
     * @type {ChannelmanagerChannelTypeWebsite}
     * @memberof ChannelmanagerUpdateChannelRequestPayload
     */
    'website'?: ChannelmanagerChannelTypeWebsite;
    /**
     * 
     * @type {ChannelmanagerChannelStatus}
     * @memberof ChannelmanagerUpdateChannelRequestPayload
     */
    'status'?: ChannelmanagerChannelStatus;
}


/**
 * 
 * @export
 * @interface ChannelmanagerUpdateMarketRequest
 */
export interface ChannelmanagerUpdateMarketRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerUpdateMarketRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerUpdateMarketRequest
     */
    'id'?: string;
    /**
     * 
     * @type {ChannelmanagerUpdateMarketRequestPayload}
     * @memberof ChannelmanagerUpdateMarketRequest
     */
    'payload'?: ChannelmanagerUpdateMarketRequestPayload;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChannelmanagerUpdateMarketRequest
     */
    'payloadMask'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ChannelmanagerUpdateMarketRequestPayload
 */
export interface ChannelmanagerUpdateMarketRequestPayload {
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerUpdateMarketRequestPayload
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelmanagerUpdateMarketRequestPayload
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ChannelmanagerCountryCode>}
     * @memberof ChannelmanagerUpdateMarketRequestPayload
     */
    'countries'?: Array<ChannelmanagerCountryCode>;
}
/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    '@type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
    /**
     * 
     * @type {number}
     * @memberof RpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RpcStatus
     */
    'details'?: Array<ProtobufAny>;
}

/**
 * ChannelManagerApi - axios parameter creator
 * @export
 */
export const ChannelManagerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new association between a channel and a market or entities
         * @summary CreateAssociation
         * @param {ChannelmanagerCreateAssociationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerCreateAssociation: async (body: ChannelmanagerCreateAssociationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerCreateAssociation', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/CreateAssociation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new channel
         * @summary CreateChannel
         * @param {ChannelmanagerCreateChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerCreateChannel: async (body: ChannelmanagerCreateChannelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerCreateChannel', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/CreateChannel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new market
         * @summary CreateMarket
         * @param {ChannelmanagerCreateMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerCreateMarket: async (body: ChannelmanagerCreateMarketRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerCreateMarket', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/CreateMarket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing association between a channel and a market or entities
         * @summary DeleteAssociation
         * @param {ChannelmanagerDeleteAssociationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerDeleteAssociation: async (body: ChannelmanagerDeleteAssociationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerDeleteAssociation', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/DeleteAssociation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft delete an existing channel
         * @summary DeleteChannel
         * @param {ChannelmanagerDeleteChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerDeleteChannel: async (body: ChannelmanagerDeleteChannelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerDeleteChannel', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/DeleteChannel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft delete an existing market
         * @summary DeleteMarket
         * @param {ChannelmanagerDeleteMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerDeleteMarket: async (body: ChannelmanagerDeleteMarketRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerDeleteMarket', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/DeleteMarket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing channel
         * @summary GetChannel
         * @param {ChannelmanagerGetChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerGetChannel: async (body: ChannelmanagerGetChannelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerGetChannel', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/GetChannel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing channel with associations
         * @summary GetChannelWithAssociations
         * @param {ChannelmanagerGetChannelWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerGetChannelWithAssociations: async (body: ChannelmanagerGetChannelWithAssociationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerGetChannelWithAssociations', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/GetChannelWithAssociations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing market
         * @summary GetMarket
         * @param {ChannelmanagerGetMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerGetMarket: async (body: ChannelmanagerGetMarketRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerGetMarket', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/GetMarket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing market with associations
         * @summary GetMarketWithAssociations
         * @param {ChannelmanagerGetMarketWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerGetMarketWithAssociations: async (body: ChannelmanagerGetMarketWithAssociationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerGetMarketWithAssociations', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/GetMarketWithAssociations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all channels
         * @summary ListChannels
         * @param {ChannelmanagerListChannelsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerListChannels: async (body: ChannelmanagerListChannelsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerListChannels', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/ListChannels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all channels with associations
         * @summary ListChannelsWithAssociations
         * @param {ChannelmanagerListChannelsWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerListChannelsWithAssociations: async (body: ChannelmanagerListChannelsWithAssociationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerListChannelsWithAssociations', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/ListChannelsWithAssociations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all markets
         * @summary ListMarkets
         * @param {ChannelmanagerListMarketsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerListMarkets: async (body: ChannelmanagerListMarketsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerListMarkets', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/ListMarkets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all markets with associations
         * @summary ListMarketsWithAssociations
         * @param {ChannelmanagerListMarketsWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerListMarketsWithAssociations: async (body: ChannelmanagerListMarketsWithAssociationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerListMarketsWithAssociations', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/ListMarketsWithAssociations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing channel
         * @summary UpdateChannel
         * @param {ChannelmanagerUpdateChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerUpdateChannel: async (body: ChannelmanagerUpdateChannelRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerUpdateChannel', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/UpdateChannel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing market
         * @summary UpdateMarket
         * @param {ChannelmanagerUpdateMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerUpdateMarket: async (body: ChannelmanagerUpdateMarketRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('channelManagerUpdateMarket', 'body', body)
            const localVarPath = `/channelmanager.ChannelManager/UpdateMarket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication standardAuthorization required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "standardAuthorization", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelManagerApi - functional programming interface
 * @export
 */
export const ChannelManagerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelManagerApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new association between a channel and a market or entities
         * @summary CreateAssociation
         * @param {ChannelmanagerCreateAssociationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerCreateAssociation(body: ChannelmanagerCreateAssociationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerAssociationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerCreateAssociation(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerCreateAssociation']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new channel
         * @summary CreateChannel
         * @param {ChannelmanagerCreateChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerCreateChannel(body: ChannelmanagerCreateChannelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerCreateChannel(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerCreateChannel']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new market
         * @summary CreateMarket
         * @param {ChannelmanagerCreateMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerCreateMarket(body: ChannelmanagerCreateMarketRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerMarketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerCreateMarket(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerCreateMarket']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete an existing association between a channel and a market or entities
         * @summary DeleteAssociation
         * @param {ChannelmanagerDeleteAssociationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerDeleteAssociation(body: ChannelmanagerDeleteAssociationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerDeleteAssociation(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerDeleteAssociation']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Soft delete an existing channel
         * @summary DeleteChannel
         * @param {ChannelmanagerDeleteChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerDeleteChannel(body: ChannelmanagerDeleteChannelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerDeleteChannel(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerDeleteChannel']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Soft delete an existing market
         * @summary DeleteMarket
         * @param {ChannelmanagerDeleteMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerDeleteMarket(body: ChannelmanagerDeleteMarketRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerDeleteMarket(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerDeleteMarket']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get an existing channel
         * @summary GetChannel
         * @param {ChannelmanagerGetChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerGetChannel(body: ChannelmanagerGetChannelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerGetChannel(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerGetChannel']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get an existing channel with associations
         * @summary GetChannelWithAssociations
         * @param {ChannelmanagerGetChannelWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerGetChannelWithAssociations(body: ChannelmanagerGetChannelWithAssociationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerChannelResponseWithAssociations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerGetChannelWithAssociations(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerGetChannelWithAssociations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get an existing market
         * @summary GetMarket
         * @param {ChannelmanagerGetMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerGetMarket(body: ChannelmanagerGetMarketRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerMarketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerGetMarket(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerGetMarket']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get an existing market with associations
         * @summary GetMarketWithAssociations
         * @param {ChannelmanagerGetMarketWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerGetMarketWithAssociations(body: ChannelmanagerGetMarketWithAssociationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerMarketResponseWithAssociations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerGetMarketWithAssociations(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerGetMarketWithAssociations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all channels
         * @summary ListChannels
         * @param {ChannelmanagerListChannelsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerListChannels(body: ChannelmanagerListChannelsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerListChannelsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerListChannels(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerListChannels']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all channels with associations
         * @summary ListChannelsWithAssociations
         * @param {ChannelmanagerListChannelsWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerListChannelsWithAssociations(body: ChannelmanagerListChannelsWithAssociationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerListChannelsWithAssociationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerListChannelsWithAssociations(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerListChannelsWithAssociations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all markets
         * @summary ListMarkets
         * @param {ChannelmanagerListMarketsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerListMarkets(body: ChannelmanagerListMarketsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerListMarketsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerListMarkets(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerListMarkets']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all markets with associations
         * @summary ListMarketsWithAssociations
         * @param {ChannelmanagerListMarketsWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerListMarketsWithAssociations(body: ChannelmanagerListMarketsWithAssociationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerListMarketsWithAssociationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerListMarketsWithAssociations(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerListMarketsWithAssociations']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update an existing channel
         * @summary UpdateChannel
         * @param {ChannelmanagerUpdateChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerUpdateChannel(body: ChannelmanagerUpdateChannelRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerChannelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerUpdateChannel(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerUpdateChannel']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update an existing market
         * @summary UpdateMarket
         * @param {ChannelmanagerUpdateMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelManagerUpdateMarket(body: ChannelmanagerUpdateMarketRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelmanagerMarketResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelManagerUpdateMarket(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChannelManagerApi.channelManagerUpdateMarket']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ChannelManagerApi - factory interface
 * @export
 */
export const ChannelManagerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelManagerApiFp(configuration)
    return {
        /**
         * Create a new association between a channel and a market or entities
         * @summary CreateAssociation
         * @param {ChannelmanagerCreateAssociationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerCreateAssociation(body: ChannelmanagerCreateAssociationRequest, options?: any): AxiosPromise<ChannelmanagerAssociationResponse> {
            return localVarFp.channelManagerCreateAssociation(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new channel
         * @summary CreateChannel
         * @param {ChannelmanagerCreateChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerCreateChannel(body: ChannelmanagerCreateChannelRequest, options?: any): AxiosPromise<ChannelmanagerChannelResponse> {
            return localVarFp.channelManagerCreateChannel(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new market
         * @summary CreateMarket
         * @param {ChannelmanagerCreateMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerCreateMarket(body: ChannelmanagerCreateMarketRequest, options?: any): AxiosPromise<ChannelmanagerMarketResponse> {
            return localVarFp.channelManagerCreateMarket(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing association between a channel and a market or entities
         * @summary DeleteAssociation
         * @param {ChannelmanagerDeleteAssociationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerDeleteAssociation(body: ChannelmanagerDeleteAssociationRequest, options?: any): AxiosPromise<object> {
            return localVarFp.channelManagerDeleteAssociation(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete an existing channel
         * @summary DeleteChannel
         * @param {ChannelmanagerDeleteChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerDeleteChannel(body: ChannelmanagerDeleteChannelRequest, options?: any): AxiosPromise<object> {
            return localVarFp.channelManagerDeleteChannel(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete an existing market
         * @summary DeleteMarket
         * @param {ChannelmanagerDeleteMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerDeleteMarket(body: ChannelmanagerDeleteMarketRequest, options?: any): AxiosPromise<object> {
            return localVarFp.channelManagerDeleteMarket(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing channel
         * @summary GetChannel
         * @param {ChannelmanagerGetChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerGetChannel(body: ChannelmanagerGetChannelRequest, options?: any): AxiosPromise<ChannelmanagerChannelResponse> {
            return localVarFp.channelManagerGetChannel(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing channel with associations
         * @summary GetChannelWithAssociations
         * @param {ChannelmanagerGetChannelWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerGetChannelWithAssociations(body: ChannelmanagerGetChannelWithAssociationsRequest, options?: any): AxiosPromise<ChannelmanagerChannelResponseWithAssociations> {
            return localVarFp.channelManagerGetChannelWithAssociations(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing market
         * @summary GetMarket
         * @param {ChannelmanagerGetMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerGetMarket(body: ChannelmanagerGetMarketRequest, options?: any): AxiosPromise<ChannelmanagerMarketResponse> {
            return localVarFp.channelManagerGetMarket(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an existing market with associations
         * @summary GetMarketWithAssociations
         * @param {ChannelmanagerGetMarketWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerGetMarketWithAssociations(body: ChannelmanagerGetMarketWithAssociationsRequest, options?: any): AxiosPromise<ChannelmanagerMarketResponseWithAssociations> {
            return localVarFp.channelManagerGetMarketWithAssociations(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List all channels
         * @summary ListChannels
         * @param {ChannelmanagerListChannelsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerListChannels(body: ChannelmanagerListChannelsRequest, options?: any): AxiosPromise<ChannelmanagerListChannelsResponse> {
            return localVarFp.channelManagerListChannels(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List all channels with associations
         * @summary ListChannelsWithAssociations
         * @param {ChannelmanagerListChannelsWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerListChannelsWithAssociations(body: ChannelmanagerListChannelsWithAssociationsRequest, options?: any): AxiosPromise<ChannelmanagerListChannelsWithAssociationsResponse> {
            return localVarFp.channelManagerListChannelsWithAssociations(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List all markets
         * @summary ListMarkets
         * @param {ChannelmanagerListMarketsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerListMarkets(body: ChannelmanagerListMarketsRequest, options?: any): AxiosPromise<ChannelmanagerListMarketsResponse> {
            return localVarFp.channelManagerListMarkets(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List all markets with associations
         * @summary ListMarketsWithAssociations
         * @param {ChannelmanagerListMarketsWithAssociationsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerListMarketsWithAssociations(body: ChannelmanagerListMarketsWithAssociationsRequest, options?: any): AxiosPromise<ChannelmanagerListMarketsWithAssociationsResponse> {
            return localVarFp.channelManagerListMarketsWithAssociations(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing channel
         * @summary UpdateChannel
         * @param {ChannelmanagerUpdateChannelRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerUpdateChannel(body: ChannelmanagerUpdateChannelRequest, options?: any): AxiosPromise<ChannelmanagerChannelResponse> {
            return localVarFp.channelManagerUpdateChannel(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing market
         * @summary UpdateMarket
         * @param {ChannelmanagerUpdateMarketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelManagerUpdateMarket(body: ChannelmanagerUpdateMarketRequest, options?: any): AxiosPromise<ChannelmanagerMarketResponse> {
            return localVarFp.channelManagerUpdateMarket(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelManagerApi - object-oriented interface
 * @export
 * @class ChannelManagerApi
 * @extends {BaseAPI}
 */
export class ChannelManagerApi extends BaseAPI {
    /**
     * Create a new association between a channel and a market or entities
     * @summary CreateAssociation
     * @param {ChannelmanagerCreateAssociationRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerCreateAssociation(body: ChannelmanagerCreateAssociationRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerCreateAssociation(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new channel
     * @summary CreateChannel
     * @param {ChannelmanagerCreateChannelRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerCreateChannel(body: ChannelmanagerCreateChannelRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerCreateChannel(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new market
     * @summary CreateMarket
     * @param {ChannelmanagerCreateMarketRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerCreateMarket(body: ChannelmanagerCreateMarketRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerCreateMarket(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing association between a channel and a market or entities
     * @summary DeleteAssociation
     * @param {ChannelmanagerDeleteAssociationRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerDeleteAssociation(body: ChannelmanagerDeleteAssociationRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerDeleteAssociation(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete an existing channel
     * @summary DeleteChannel
     * @param {ChannelmanagerDeleteChannelRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerDeleteChannel(body: ChannelmanagerDeleteChannelRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerDeleteChannel(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete an existing market
     * @summary DeleteMarket
     * @param {ChannelmanagerDeleteMarketRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerDeleteMarket(body: ChannelmanagerDeleteMarketRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerDeleteMarket(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing channel
     * @summary GetChannel
     * @param {ChannelmanagerGetChannelRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerGetChannel(body: ChannelmanagerGetChannelRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerGetChannel(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing channel with associations
     * @summary GetChannelWithAssociations
     * @param {ChannelmanagerGetChannelWithAssociationsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerGetChannelWithAssociations(body: ChannelmanagerGetChannelWithAssociationsRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerGetChannelWithAssociations(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing market
     * @summary GetMarket
     * @param {ChannelmanagerGetMarketRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerGetMarket(body: ChannelmanagerGetMarketRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerGetMarket(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an existing market with associations
     * @summary GetMarketWithAssociations
     * @param {ChannelmanagerGetMarketWithAssociationsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerGetMarketWithAssociations(body: ChannelmanagerGetMarketWithAssociationsRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerGetMarketWithAssociations(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all channels
     * @summary ListChannels
     * @param {ChannelmanagerListChannelsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerListChannels(body: ChannelmanagerListChannelsRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerListChannels(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all channels with associations
     * @summary ListChannelsWithAssociations
     * @param {ChannelmanagerListChannelsWithAssociationsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerListChannelsWithAssociations(body: ChannelmanagerListChannelsWithAssociationsRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerListChannelsWithAssociations(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all markets
     * @summary ListMarkets
     * @param {ChannelmanagerListMarketsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerListMarkets(body: ChannelmanagerListMarketsRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerListMarkets(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all markets with associations
     * @summary ListMarketsWithAssociations
     * @param {ChannelmanagerListMarketsWithAssociationsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerListMarketsWithAssociations(body: ChannelmanagerListMarketsWithAssociationsRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerListMarketsWithAssociations(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing channel
     * @summary UpdateChannel
     * @param {ChannelmanagerUpdateChannelRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerUpdateChannel(body: ChannelmanagerUpdateChannelRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerUpdateChannel(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing market
     * @summary UpdateMarket
     * @param {ChannelmanagerUpdateMarketRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelManagerApi
     */
    public channelManagerUpdateMarket(body: ChannelmanagerUpdateMarketRequest, options?: RawAxiosRequestConfig) {
        return ChannelManagerApiFp(this.configuration).channelManagerUpdateMarket(body, options).then((request) => request(this.axios, this.basePath));
    }
}



